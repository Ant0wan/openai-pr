---

## ðŸ“š Sources

[how-to-write-your-own-github-action](https://towardsdatascience.com/how-to-write-your-own-github-action-59cc4746a57a)
[gh_pr_diff](https://cli.github.com/manual/gh_pr_diff)
[Writing Your First Python GitHub Action](https://shipyard.build/blog/your-first-python-github-action/)

[How to Test a GitHub Action with GitHub Actions](https://dev.to/cicirello/how-to-test-a-github-action-with-github-actions-2hag)


---

## ðŸ›  Continuous Integration

- **Linting**: Running linters like Pylint or Flake8 to ensure code quality and adherence to coding standards.
- **Unit Testing**: Executing unit tests to verify the functionality of individual units of code. Tools like pytest or unittest can be used for this purpose.
- **Code Coverage**: Calculating code coverage to determine the percentage of code that is covered by tests. Tools like coverage.py or pytest-cov can generate code coverage reports.
- **Static Analysis**: Conducting static analysis on the codebase to identify potential issues or bugs. Tools like Bandit or Pyright can be employed for static analysis.
- **Type Checking**: Utilizing a static type checker such as MyPy to validate the type annotations in your Python code.
- **Dependency Management**: Verifying that dependencies are correctly installed and up to date. Tools like pip or poetry can be used for dependency management.
- **Build and Packaging**: Building and packaging the project into distributable formats like source distributions (sdist) or wheel distributions (bdist_wheel).
- **Documentation Generation**: Generating documentation from docstrings or other sources using tools like Sphinx or mkdocs.
- **Integration Testing**: Performing integration tests to validate the interactions between different components or services of your application.
- **Deployment**: Deploying the application to a staging or production environment. This step might involve additional procedures like containerization, orchestration, or deployment to cloud platforms.
